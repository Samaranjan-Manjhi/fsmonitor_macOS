/*This code generated by Samaranjan Manjhi for macOS to monitor the File System Events in the Entire System on 27 December 2024. In this code we log 
for Created Event, Modified Events, Deleted Events, Move Events with fullpath including file/folder name. For Some of the restictions of the macOS 
services/ protection (System Integrity Protection --- SIP) I am unable to detect the Copy Events Source path but able to get the Destination path while in Move Events got both Source and Destination Path.*/

/*
---> Daemonize Program
---> Logging File with timestamp
---> While Logging into file if file deleted/Moved it will create a New file with the same name && if log file size is 50MB then file will truncate
---> Some of the file name excluded while writing into file
---> Monitoring Entire System "/" by default if no Folder mention by the user
*/

#include <CoreServices/CoreServices.h>
#include <stdio.h>
#include <libgen.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/param.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <signal.h>
#include <sys/stat.h>

#define MAX_LOG_FILE_SIZE (5 * 1024 * 1024) // 50 MB
#define LOG_FILE_PATH "/tmp/fsevents_log.txt"

FILE *log_file = NULL;
char last_rename_source[MAXPATHLEN] = {0}; // Store the last rename source path
char last_logged_path[MAXPATHLEN] = {0};   // Store the last logged path to prevent duplicates

// List of filenames to exclude from logging
const char *excluded_files[] = {
    "LiveFiles.ticotsord",
    "mwconnect.log",
    "libmwshare.log",
    "escanmon.log",
    "clients.plist",
    "fsevents_log.txt",
    "launchd.log",
    "softwarelist_data.txt",
    "softwares.list",
    "softwares.list.tmp",
    "mwsystem_profiler",
    "mwsystem_profiler.tmp",
    "auditd.pid",
    "window_9.data",
    "window_7.data",
    "live.2.indexHead",
    ".store.db",
    "pcs.db",
    "pcs.db-shm",
    "Info.plist",
    ".viminfo",
    "NSIRD_locationd_eInWAL",
    NULL // Null-terminated for iteration
};

// Function to check if a filename is in the exclusion list
int isExcludedFile(const char *filename) {
    for (const char **excluded = excluded_files; *excluded != NULL; excluded++) {
        if (strcmp(filename, *excluded) == 0) {
            return 1; // Match found in exclusion list
        }
    }
    return 0; // No match found
}

// Function to get the current timestamp
void getCurrentTime(char *buffer, size_t size) {
    time_t now = time(NULL);
    struct tm *local_time = localtime(&now);
    strftime(buffer, size, "%Y-%m-%d %H:%M:%S", local_time);
}

// Function to open the log file, creating it if necessary
void openLogFile() {
    log_file = fopen(LOG_FILE_PATH, "a");
    if (!log_file) {
        perror("Failed to open log file");
        exit(1);
    }

    // Write header to the log file if empty
    fseek(log_file, 0, SEEK_END);
    if (ftell(log_file) == 0) {
        //fprintf(log_file, "Timestamp, Action, Path, Filename\n");
    }
}

// Function to truncate the log file
void truncateLogFile() {
    if (log_file) {
        fclose(log_file);
        log_file = fopen(LOG_FILE_PATH, "w"); // Reopen the file in write mode to truncate
        if (!log_file) {
            perror("Failed to truncate log file");
            exit(1);
        }
        printf("Log file truncated due to size limit.\n");
    }
}

// Function to check the log file size and truncate if necessary
void checkLogFileSize() {
    struct stat st;
    if (stat(LOG_FILE_PATH, &st) == 0) {
        if (st.st_size > MAX_LOG_FILE_SIZE) {
            truncateLogFile();
        }
    }
}

// Function to log events
void logEvent(const char *action, const char *path, const char *filename) {
    char time_buffer[20];
    getCurrentTime(time_buffer, sizeof(time_buffer));

    // Check if the log file is still accessible
    if (!log_file || access(LOG_FILE_PATH, F_OK) != 0) {
        openLogFile(); // Reopen the log file if it was deleted
    }

    // Check log file size and truncate if necessary
    checkLogFileSize();

    // Write log entry
    if (log_file) {
        fprintf(log_file, "%s, %s, %s, %s\n", time_buffer, action, path, filename);
        fflush(log_file); // Ensure the data is written to the file immediately
    }
}

// Callback for FSEvents
void eventCallback(
    ConstFSEventStreamRef streamRef,
    void *clientCallBackInfo,
    size_t numEvents,
    void *eventPaths,
    const FSEventStreamEventFlags eventFlags[],
    const FSEventStreamEventId eventIds[]) {
    char **paths = (char **)eventPaths;
    for (size_t i = 0; i < numEvents; i++) {
        char *fileName = basename(paths[i]);
        // Skip logging if the file is in the exclusion list
        if (isExcludedFile(fileName)) {
            continue;
        }
        const char *action = NULL;
        if (eventFlags[i] & kFSEventStreamEventFlagItemCreated) {
            action = "Created";
        } else if (eventFlags[i] & kFSEventStreamEventFlagItemRemoved) {
            action = "Deleted";
        } else if (eventFlags[i] & kFSEventStreamEventFlagItemModified) {
            action = "Modified";
        } else if (eventFlags[i] & kFSEventStreamEventFlagItemRenamed) {
            // Handle renames with source-destination pairing
            if (strlen(last_rename_source) == 0) {
                // Record the source path
                snprintf(last_rename_source, MAXPATHLEN, "%s", paths[i]);
                logEvent("Moved ", paths[i], fileName);
                printf("Moved (Source) %s \t %s\n",paths[i], fileName);
            } else if (strcmp(last_rename_source, paths[i]) != 0 ) {
                // Log the destination path only if it differs from the source
                logEvent("Moved ", paths[i], fileName);
                printf("Moved (Destination) %s \t %s\n",paths[i], fileName);
                memset(last_rename_source, 0, sizeof(last_rename_source)); // Clear the source
            }
            continue; // Skip further processing for rename events
        }

        // Prevent duplicate logs
        if (action && strcmp(last_logged_path, paths[i]) != 0) {
            logEvent(action, paths[i], fileName);
            snprintf(last_logged_path, MAXPATHLEN, "%s", paths[i]);
        }
    }
}

// Daemonize the process
void daemonize() {
    pid_t pid = fork();
    if (pid < 0) {
        perror("Fork failed");
        exit(1);
    }
    if (pid > 0) {
        exit(0); // Parent process exits
    }

    // Create a new session and detach from the terminal
    if (setsid() < 0) {
        perror("Failed to create a new session");
        exit(1);
    }

    // Redirect standard file descriptors to /dev/null
    freopen("/dev/null", "r", stdin);
    freopen("/dev/null", "w", stdout);
    freopen("/dev/null", "w", stderr);
}

int main(int argc, const char *argv[]) {
//    daemonize(); // Daemonize the process

    openLogFile(); // Open the log file

    // Default to watching the root directory if no directory is provided
    const char *path = (argc < 2) ? "/" : argv[1];

    CFStringRef pathToWatch = CFStringCreateWithCString(NULL, path, kCFStringEncodingUTF8);
    CFArrayRef pathsToWatch = CFArrayCreate(NULL, (const void **)&pathToWatch, 1, NULL);

    FSEventStreamContext context = {0, NULL, NULL, NULL, NULL};
    FSEventStreamRef stream = FSEventStreamCreate(
        NULL,
        &eventCallback,
        &context,
        pathsToWatch,
        kFSEventStreamEventIdSinceNow,
        1.0, // Latency in seconds
        kFSEventStreamCreateFlagFileEvents // Report individual file events
    );

    FSEventStreamScheduleWithRunLoop(stream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
    FSEventStreamStart(stream);

    CFRunLoopRun();

    FSEventStreamStop(stream);
    FSEventStreamInvalidate(stream);
    FSEventStreamRelease(stream);
    CFRelease(pathsToWatch);
    CFRelease(pathToWatch);

    fclose(log_file); // Close the log file
    return 0;
}

